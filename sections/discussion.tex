\section{Discussion} % Qualitative evaluation

% Alternative solutions
% Discuss weaknesses and strengths

\subsection{Sequential Prefetcher}

From running the tests on different configurations on a sequential
prefetcher we got some interesting results. For example, \texttt{ammp}
produced the slowest results with every configuration. On average, the
different configurations produced results close to baseline,
especially for the integer computation tests shown in
Figure~\ref{graph:seq}. \texttt{wupwise} gets the highest speedup for
every configuration, suggesting it does a lot of memory accessing and
benefits from prefetching even if the prefetcher method is simple.

\subsection{GHB and RPT}
The two main prefetchers that were implemented were surprisingly
similar in performance over the whole benchmark suite. Generally, they
performed better for floating point tests. Neither of them scored high
in any of the data compression tests \texttt{bzip2\_*}, and both got
their highest speed up when running \texttt{wupwise} which is a simulation of
quantum hydrodynamics. The only thing that can be said for sure about
this result is that the tests with floating point calculations probably
have the same stride more often for subsequent load instructions from
the same place in the program. Overall, the prefetchers only score
under 1.00 (which is the baseline) on one test, \texttt{twolf} = 0.99,
which is a place and route simulator. Regarding this result, it would
be safe to say that the prefetchers won't harm the overall performance
of the computer should one choose to implement one of these schemes.
