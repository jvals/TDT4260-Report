\section{Proposed solution}\todo{Think of a better heading}

% Explain how the proposed solution works
% Give enough details to be understood but no more than necessary to
% keep the message clear.
% Enough information for the solution to be implementable
% Use illustrations when possible to convey the message

\subsection{Reference Prediction Tables}

In RPT, we keep a table with entries corresponding to load
instructions. Every time the program counter hits a load, the current
address (tag), as well as the memory location we load from (previous
address), is stored as an entry in this table. When we encounter a tag
which already resides in the table, we check what address we are about
to load from, and from that, subtract the previous address. The result
of this subtraction is stored in the corresponding entry as the
``stride''. The complete format of an entry is shown in
Table~\ref{table:entry}.

\begin{table}
  \centering
  \begin{tabular}{ | c | c | c | c |}
    \hline
    Tag & Previous Address & Stride & State \\ \hline
  \end{tabular}
  \caption{RPT Entry}
  \label{table:entry}
\end{table}

If two consecutive strides are equal, this indicates an access pattern
we can make use of. A prefetch is issued if the block is not in cache.

To avoid bad prefetches, we use a state machine which indicates the
current status of the system. Initially, an entry has state
``init''. Every time we encounter an entry which already resides in
the table, we check if the stride is equal to the one we have stored
in the entry. That is, we check if current\_address$ -
$previous\_address = stride. Depending on if this is true (correct) or
not (incorrect), we move to a new state. The state machine is shown in
Figure~\ref{figure:statemachine}. If the entry has state init,
transient or steady, we can consider issuing a prefetch.

\begin{table}
  \centering
  \begin{tabular}{ | c | c | c | c | c |}
    \hline
    Tag & Previous Address & Stride & State & Times \\ \hline
  \end{tabular}
  \caption{RPT Entry with lookahead}
  \label{table:entry_la}
\end{table}

An improvement on this design is to issue multiple prefetches at the
same time. This is done to prevent data arriving too late, or being
replaced too early. A variable \texttt{times} is introduced (shown in
Table~\ref{table:entry_la}) and initially is set to 1. Each time we get a table hit, we
increment \texttt{times} (up to a fixed lookahead limit) if the
correct-condition is true. If not, we decrement (down to a limit of
1). Instead of issuing a single prefetch, we now issue a batch of
prefetches with address = previous\_address$ + $stride$\times$i,
where i $= [1, 2, \ldots, \texttt{times}]$.

% State machine
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[node distance=3cm,on grid,auto]
   \node[state] (q_0)   {init};
   \node[state] (q_1) [right=of q_0] {steady};
   \node[state] (q_2) [below=of q_0] {transient};
   \node[state] (q_3) [right=of q_2] {no-pred};
    \path[->]
    (q_0) edge  [out=5, in=175] node {correct} (q_1)
          edge  node [swap, text width=2.3cm] {\hspace{0.4cm}incorrect
            (update stride)} (q_2)
    (q_1) edge [out=185, in=355, looseness=1] node {incorrect} (q_0)
          edge [loop right] node {correct} ()
    (q_2) edge  [out=355, in=185] node [swap, text width=2.3cm] {\hspace{0.4cm}incorrect (update stride)} (q_3)
          edge  node [swap] {correct} (q_1)
    (q_3) edge [out=175, in=5] node [swap] {correct} (q_2)
          edge  [loop right] node [text width=2.3cm] {\hspace{0.4cm}incorrect (update stride)} ();
\end{tikzpicture}
\caption{State machine as proposed in~\cite{chen_baer_1995}}
\label{figure:statemachine}
\end{center}

\subsection{Global History Buffer with PC/DC}
A global history buffer (GHB) is a FIFO table where each entry is an
element of a linked list. This means that an entry contains a pointer
to the previous entry generated by the same address. Every time an
address is requested, it is pushed into the GHB.

A smaller table, the index table, is used to keep pointers into the
GHB. The index table is accessed the same way as in other table-based
prefetchers. In this case, the address of the load instruction acts as
the key. Each index table entry has a PC field and a ghb pointer
field.

After accessing the index table, if the PC field does not match the PC
of the load instruction, the field is updated. However, if the PC
field does match, the current ghb entry's back pointer is set to the
address of the ghb pointer. Finally, the ghb pointer is set to the
head of the GHB buffer.

A delta table is built by traversing the back pointers and storing the
difference (delta) between consecutive miss addresses. The delta table
is traversed to find a delta pair equal to the first pair of deltas,
this is called delta correlating. If a pattern is found, a prefetch is
issued for the address equal to delta$+$current miss address, where
delta is every delta between the matching pairs.

\end{figure}
